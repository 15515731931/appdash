{{define "Title"}}{{if .Trace.ID.Parent}}span {{.Trace.ID.Span}} - {{end}} trace {{.Trace.ID.Trace}} - apptrace{{end}}

{{define "Main"}}
<h1>Trace {{.Trace.ID.Trace}}</h1>
{{if .Trace.ID.Parent}}<h2>Sub-span {{.Trace.ID.Span}}</h2>{{end}}

<div>
<div id="#trace-{{.Trace.ID.Trace}}" class="trace-timeline"></div>
<div id="hoverRes">
  <div class="coloredDiv"></div>
  <div id="name"></div>
  <div id="scrolled_date"></div>
</div>
</div>


<div id="contextMenu" class="dropdown clearfix">
  <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu" style="display:block;position:static;margin-bottom:5px;">
    <li role="presentation" class="name dropdown-header"></li>

    <li><a tabindex="-1" data-action="show-children" href="#" data-toggle="tooltip" data-placement="right" title="show all children below this span">Show Children</a></li>
    <li><a tabindex="-1" data-action="hide-children" href="#" data-toggle="tooltip" data-placement="right" title="hide all children below this span">Hide Children</a></li>
    <li><a tabindex="-1" data-action="filter" href="#" data-toggle="tooltip" data-placement="right" title="show/hide all children based on a filter">Filter</a></li>

    <li><a tabindex="-1" href="#" data-action="close">Close</a></li>
  </ul>
</div>


<div id="contextFilterMenu" class="dropdown clearfix">
  <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu" style="display:block;position:static;margin-bottom:5px;">
    <li role="presentation" class="dropdown-header"><span class="name"></span>: Filter</li>

    <li><input type="text" class="filter form-control" data-toggle="tooltip" data-placement="right" title="type a key:value pair and press enter to apply the filter" placeholder='key:value...'></li>

    <li><a tabindex="-1" href="#" data-action="close">Close</a></li>
  </ul>
</div>


<style type="text/css">
 .axis path,
 .axis line {
   fill: none;
   stroke: black;
   shape-rendering: crispEdges;
 }
 .axis text {
   font-family: sans-serif;
   font-size: 10px;
 }
 .timeline-label {
   font-family: sans-serif;
   font-size: 12px;
 }
 #timeline2 .axis {
   transform: translate(0px,30px);
   -ms-transform: translate(0px,30px); /* IE 9 */
   -webkit-transform: translate(0px,30px); /* Safari and Chrome */
   -o-transform: translate(0px,30px); /* Opera */
   -moz-transform: translate(0px,30px); /* Firefox */
 }
 #hoverRes .coloredDiv {
   height:20px; width:20px; float:left;
 }
 #hoverRes #name {
   display: inline-block;
   margin-left: 0.3em;
 }
 #contextMenu, #contextFilterMenu {
   font-family: sans-serif;
   font-size: 12px;
   position: absolute;
   display: none;
 }
 #contextMenu .dropdown-menu>li>span {
   display: block;
   padding: 3px 20px;
   clear: both;
   font-weight: 400;
   line-height: 1.42857143;
   color: #333;
   white-space: nowrap;
 }
</style>

<script type="text/javascript">
 var data = {{.VisData}};
 var width = $(".container").width();

 // em converts the input (in em units) to pixels units and returns it.
 function em(emUnits) {
   var fontSize = parseFloat($('body').css('font-size'));
   return fontSize * emUnits;
 }

 // numFromEnd returns the number from the end of the potentially garbage
 // string, e.g. "timelineItem_1443" -> 1443
 function numFromEnd(str) {
   return parseInt(str.match(/(\d+)$/)[0], 10);
 }

 // Initialize bootstrap tooltips.
 $('[data-toggle="tooltip"]').tooltip();

 // setChildrenVisible walks through the data and finds all children (including
 // distant ones) of the given spanID. It marks each one as visible (true or
 // false).
 function setChildrenVisible(spanID, visible) {
   $.each(data, function(i, other) {
     if(other.parentSpanID != spanID) {
       return;
     }
     other.visible = visible;
     setChildrenVisible(other.spanID, visible);
   });
 }

 // filterChildrenFuzzy uses Fuse to fuzzy-search through the data (
 // specifically, the names and tags) and hides all children elements that do
 // not match.
 function filterChildrenFuzzy(spanID, filter) {
   // Use fuse to fuzzy-search through our dataset with the given filter.
   var options = {
     caseSensitive: false,
     shouldSort: true,
     threshold: 0.3, // A lower threshold is more strict, higher is less.
     keys: ["rawData.Name", "rawData.Tag"] // Data fields to search on.
   };
   var fuse = new Fuse(data, options);
   var results = fuse.search(filter);

   // Recursively descend into each span showing and hiding each one based on
   // our search results.
   var descend = null;
   descend = function(parentSpanID) {
     $.each(data, function(i, other) {
       // Check that the span we're looking at is a child of the given parent
       // span.
       if(other.parentSpanID != parentSpanID) {
         return;
       }

       // Depending on whether or not the span showed up in our fuzzy search
       // results, we show or hide it.
       other.visible = false;
       $.each(results, function(i, result) {
         if(result.spanID != other.spanID) {
           return;
         }
         other.visible = true;
         return false; // stop the search.
       });

       // Descend into that span's children.
       descend(other.spanID);
     });
   }
   descend(spanID);
 }

 // filterChildren walks through the data and finds all children (including
 // distant ones) of the given spanID. It uses a filter to mark each child span
 // as visible or not.
 //
 // A strict search is defined by a key followed by a colon and a quoted value.
 //
 //  Key:"expected value"
 //
 // For example:
 //
 //  Name:"Request"
 //
 // If a filter does not match the above strict-searching pattern,
 // filterChildren silently falls back to fuse-based fuzzy searching.
 function filterChildren(spanID, filter) {
   // Validate the filter.
   var splitFilter = filter.split(":");
   if(splitFilter.length != 2) {
     // Missing colon for strict search, fallback to fuzzy search then.
     filterChildrenFuzzy(spanID, filter);
     return;
   }
   var k = splitFilter[0];
   var v = splitFilter[1];
   if(v[0] !== '"' || v[v.length-1] !== '"') {
     // Missing quoted value for strict search, fallback to fuzzy search then.
     filterChildrenFuzzy(spanID, filter);
     return;
   }
   // Strip leading and trailing quotes from value:
   v = v.slice(1, v.length-1);

   $.each(data, function(i, other) {
     if(other.parentSpanID != spanID) {
       return;
     }

     // Check if the span has a key and value exactly matching our filter.
     if(other.rawData[k] == v) {
       other.visible = true;
     } else {
       other.visible = false;
     }
     filterChildren(other.spanID, filter);
   });
 }

 // When the user presses the Close button in the context menu, we hide it. We
 // declare this as a separate function so that other context menu items can
 // quickly hide the context menu as well (see below).
 function ctxMenuActionClose(e) {
   e.preventDefault();
   $("#contextMenu").hide();
 }
 $('#contextMenu a[data-action="close"]').on("click", ctxMenuActionClose);

 // ctxMenuActionShowHide is the implementation for the context menu's Show
 // Children and Hide Children buttons.
 function ctxMenuActionShowHide(e, visible) {
   ctxMenuActionClose(e);
   var spanID = $("#contextMenu").data("dataObject").spanID;
   setChildrenVisible(spanID, visible)
   timelineHover();
 }

 // Event handlers for each context menu Show/Hide button.
 $('#contextMenu a[data-action="show-children"]').on("click", function(e) { ctxMenuActionShowHide(e, true) });
 $('#contextMenu a[data-action="hide-children"]').on("click", function(e) { ctxMenuActionShowHide(e, false) });

 // Event handler for the filter submenu.
 $('#contextMenu a[data-action="filter"]').on("click", function(e) {
   // Close the normal context menu.
   ctxMenuActionClose(e);

   // Display the submenu.
   $("#contextFilterMenu .name").html($("#contextMenu .name").html());
   $("#contextFilterMenu").css({
     display: "block",
     left: $("#contextMenu").css("left"),
     top: $("#contextMenu").css("top")
   });
   $('#contextFilterMenu .filter').select();
 });

 // Hide the filter context-submenu when the user presses the close button.
 $('#contextFilterMenu a[data-action="close"]').on("click", function(e) {
   e.preventDefault();
   $("#contextFilterMenu").hide();
 });

 // When the user types something into the filter text input and presses enter,
 // we apply the filter to all children below the target span.
 $('#contextFilterMenu .filter').keyup(function(e) {
   if(e.keyCode != 13) {
     return; // Not enter.
   }
   // Hide the context menu, grab the target span ID, and filter the children.
   var spanID = $("#contextMenu").data("dataObject").spanID;
   filterChildren(spanID, $(this).val())
   $("#contextFilterMenu").hide();
   timelineHover();
 });

 function ctxMenuOpen(e, datum, obj) {
   $("#contextFilterMenu").hide();
   $("#contextMenu").data("dataObject", obj);
   $("#contextMenu .name").html(datum.label);
   $("#contextMenu").css({
     display: "block",
     left: e.pageX,
     top: e.pageY
   });
   return false;
 }

 function timelineHover() {
   // When rebuilding the timeline to account for changes, we must first empty
   // it completely.
   $(".trace-timeline").empty();

   // Copy just the visible objects of the data for passing into d3-timeline.
   var visibleData = [];
   $.each(data, function(i, obj) {
     if(!obj.visible) {
       return;
     }
     visibleData.push(obj);
   });
   if(visibleData.length == 0) {
     return;
   }

   var timespanHover = function(chart, index) {
     var div = $('#hoverRes');
     var colors = chart.colors();
     div.find('.coloredDiv').css('background-color', colors(index));
     div.find('#name').text(visibleData[index].label);
   }

   // Initialize the timeline chart.
   var chart = d3.timeline()
                 .width(width)
                 .stack()
                 .margin({left:em(6), right:0, top:0, bottom:0})
                 .hover(function (d, i, datum) { timespanHover(chart, i) })
                 .click(function (d, i, datum) {
                   window.location.href = datum.url;
                   //alert(JSON.stringify(datum.rawData, null, 2));
                 });
   var svg = d3.select(".trace-timeline").append("svg").attr("width", width)
               .datum(visibleData).call(chart);

   // Make text on each timeline element click-able. d3-timeline.js doesn't
   // seem to have a way to support this easily.
   //
   // We do this by selecting the text element, finding the prev element (the
   // SVG rect), and then parsing the ID (which looks like: "timelineItem_1").
   //
   // The last number of that is the index into our visibleData.
   $(".trace-timeline g>text").each(function() {
     var index = numFromEnd($(this).prev().attr('id'));
     $(this).hover(function() {
       timespanHover(chart, index);
     });
     $(this).click(function() {
       window.location.href = visibleData[index].url;
     });

     // When there is a contextmenu (e.g. right click) event we open the
     // context menu on the timespan rectangle.
     var datum = d3.select($(this).prev()[0]).data()[0];
     $(this).on("contextmenu", function(e) { return ctxMenuOpen(e, datum, visibleData[index]) });
     $(this).prev().on("contextmenu", function(e) { return ctxMenuOpen(e, datum, visibleData[index]) });
   });
 }

 if(data != null) {
   timelineHover();
 }
</script>

<ul class="traces">
  {{template "Trace" .Trace}}
</ul>

{{end}}

